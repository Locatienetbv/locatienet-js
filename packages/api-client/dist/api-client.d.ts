// Generated by dts-bundle-generator v9.5.1

import { Feature, LineString, Point, Position } from 'geojson';

/**
 * Represents the address of a geographical object. Where a string, such as a city or street name, is available in multiple languages, it is returned in the default language specified by the object's location, i.e. in which country it is located. Because addressing schemes vary strongly between countries, most fields are optional.
 */
export type Address = {
	/**
	 * The postal code of the address.
	 */
	postcode?: string | null;
	/**
	 * The street name of the address
	 */
	street?: string | null;
	/**
	 * The HouseNr of the address
	 */
	houseNr?: string | null;
	/**
	 * The district of the address, i.e. the entity below city.
	 */
	district?: string | null;
	/**
	 * The city of the address,
	 */
	city?: string | null;
	/**
	 * The name of the principal country subdivision which the address belongs to
	 */
	province?: string | null;
	/**
	 * Country code according to ISO 3166-1 alpha-2. Defaults to NL. The search will be restricted to this country. When empty, all countries contained in the geocoding data will be included in the search.
	 */
	country?: string | null;
};
type BoundingBox = {
	/**
	 * Minimum value for x dimension. The numerical value has to be less than or equal to maxX.
	 */
	minX?: number;
	/**
	 * Maximum value for x dimension. The numerical value has to be greater than or equal to minX.
	 */
	maxY?: number;
	/**
	 * Minimum value for y dimension. The numerical value has to be less than or equal to maxY.
	 */
	maxX?: number;
	/**
	 * Maximum value for y dimension. The numerical value has to be greater than or equal to minY.
	 */
	minY?: number;
};
/**
 * A coordinate is defined by its x and y values, specifying the geographical point in a two-dimensional coordinate system
 */
export type Coordinate = {
	/**
	 * The value in x-direction (west to east), longitude for WGS84.
	 */
	"x"?: number;
	/**
	 * The value in y-direction (south to north), latitude for WGS84.
	 */
	"y"?: number;
};
/**
 * Represents a geographical object in terms of its position and its address.
 */
type Location$1 = {
	/**
	 * The postal code of the address.
	 */
	postcode?: string | null;
	/**
	 * The street name of the address
	 */
	street?: string | null;
	/**
	 * The HouseNr of the address
	 */
	houseNr?: string | null;
	/**
	 * The district of the address, i.e. the entity below city.
	 */
	district?: string | null;
	/**
	 * The city of the address,
	 */
	city?: string | null;
	/**
	 * The name of the principal country subdivision which the address belongs to
	 */
	province?: string | null;
	/**
	 * Country code according to ISO 3166-1 alpha-2. Defaults to NL. The search will be restricted to this country. When empty, all countries contained in the geocoding data will be included in the search.
	 */
	country?: string | null;
	coordinate?: Coordinate;
	/**
	 * Indicates the overall match quality for a geocoding request. 100 (percent) represents a perfect match between the input and the result.
	 */
	score?: number;
	/**
	 * A radius that specifies how close the route shall pass by the specified coordinate, only to be used with via waypoints. This radius refers to the distance on the road network in meters.
	 * When set there is no output waypoint. The route passes near the specified coordinate.
	 */
	distance?: number | null;
	/**
	 * A single string representing the address, typically consisting of the street, house number, postal code, city, and country. The precise format may differ based on what is appropriate for the address.
	 */
	description?: string | null;
};
type Country = {
	value?: string | null;
	iso2?: string | null;
	iso3?: string | null;
	lang?: Record<string, string> | null;
	bBox?: BoundingBox;
};
type CountryType = "ISO31661ALPHA2" | "ISO31661ALPHA3" | "LICENSEPLATE" | "NAME";
export type LocateOptions = {
	/**
	 * The language used for geographic names. Defaults to nl. This standard allows to use two-letter ISO 639-1 codes
	 */
	language?: string | null;
	/**
	 * Limit the number of resulting locations (default 5)
	 */
	numResults?: number | null;
	/**
	 * Minimal score of the results (default 70)
	 */
	minimalResultScore?: number | null;
	outputCountryType?: CountryType;
};
type RouteOptimization = "shortest" | "optimal" | "fastest";
type TimeConsiderationType = "Snapshot" | "ExactAtArrival" | "ExactAtStart";
type VehicleType = "car" | "carfast" | "carslow" | "van" | "vanslow" | "boxtruck" | "truckfast" | "truckslow" | "bicycle" | "pedestrian";
export type RouteOptions = {
	vehicle?: VehicleType;
	optimization?: RouteOptimization;
	/**
	 * The language of texts such as maneuver or traffic-incident descriptions. Defaults to nl. This standard allows to use two-letter ISO 639-1 codes
	 */
	language?: string | null;
	/**
	 * Force the routing algorithm to avoid freeways
	 */
	avoidHighways?: boolean;
	/**
	 * Force the routing algorithm to avoid tollroads
	 */
	avoidToll?: boolean;
	/**
	 * Force the routing algorithm to avoid ferries
	 */
	avoidFerry?: boolean;
	/**
	 * Force the routing algorithm to avoid current traffic
	 */
	avoidTrafficIncidents?: boolean;
	/**
	 * Force the routing algorithm to avoid emissionzones
	 */
	avoidEmissionZones?: boolean;
	referenceTime?: string;
	timeConsiderationType?: TimeConsiderationType;
	/**
	 * Include the polyline of the route. The polyline is a list of sequential coordinates of roadnodes
	 */
	includePolyline?: boolean;
};
interface LocateFeatureResult extends Feature<Point> {
	properties: Address;
}
declare function locateByText(query: string, country?: string, options?: LocateOptions): Promise<Array<LocateFeatureResult>>;
declare function locateByAddress(address: Address, options?: LocateOptions): Promise<Array<LocateFeatureResult>>;
declare function locateByPosition(position: Coordinate | Position, options?: LocateOptions): Promise<Array<LocateFeatureResult>>;
interface RouteInfoFeatureResult extends Feature<LineString> {
	properties: {
		distance?: number;
		travelTime?: number;
	};
}
declare function calculateRouteInfo(locations?: Location$1[], options?: RouteOptions): Promise<RouteInfoFeatureResult>;
declare function countries(): Promise<Country[]>;
/** @type {*} */
export declare const Api: {
	apikey: any;
	/**
	 * Search for locations using a free-form text input.
	 *
	 * @param {string} query input
	 * @param {string} [country]
	 * @param {LocateOptions} [options]
	 * @returns {*}  {Promise<Array<LocateFeatureResult>>}
	 */
	locateByText: typeof locateByText;
	/**
	 * Search for locations using structured address input.
	 *
	 * @param {Address} address
	 * @param {LocateOptions} [options]
	 * @returns {*}  {Promise<Array<LocateFeatureResult>>}
	 */
	locateByAddress: typeof locateByAddress;
	/**
	 * Search for addresses using structured coordinate input.
	 *
	 * @param {(Coordinate | Position)} position
	 * @param {LocateOptions} [options]
	 * @returns {*}  {Promise<Array<LocateFeatureResult>>}
	 */
	locateByPosition: typeof locateByPosition;
	/**
	 * Calculates and returns basic route information and polyline as GeoJSON Feature.
	 *
	 * @param {Location[]} [locations]
	 * @param {RouteOptions} [options]
	 * @returns {*}  {Promise<RouteInfoFeatureResult>}
	 */
	calculateRouteInfo: typeof calculateRouteInfo;
	/**
	 * Calculates and returns basic route information, descriptions and polyline.
	 *
	 * @param {Location[]} [locations]
	 * @param {RouteOptions} [options]
	 * @returns {*}  {Promise<CalculateRouteDescriptionResponse>}
	 */
	calculateRoute: typeof calculateRouteInfo;
	/**
	 * Fetch all EU country information, name in different languages and their iso codes
	 *
	 * @returns {*}  {Promise<Country[]>}
	 */
	countries: typeof countries;
};

export {
	Location$1 as Location,
};

export as namespace LocatienetApiClient;

export {};
